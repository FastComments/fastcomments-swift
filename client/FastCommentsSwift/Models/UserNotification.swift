//
// UserNotification.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct UserNotification: Sendable, Codable, JSONEncodable, Hashable {

    public var id: String
    public var tenantId: String
    public var userId: String?
    public var anonUserId: String?
    public var urlId: String
    public var url: String
    public var pageTitle: String?
    public var relatedObjectType: NotificationObjectType
    public var relatedObjectId: String
    public var viewed: Bool
    public var isUnreadMessage: Bool
    public var sent: Bool
    public var createdAt: Date
    public var type: NotificationType
    public var fromCommentId: String?
    public var fromVoteId: String?
    public var fromUserName: String?
    public var fromUserId: String?
    public var fromUserAvatarSrc: String?
    public var optedOut: Bool
    public var count: Int64?
    public var relatedIds: [String]?
    public var fromUserIds: [String]?
    public var fromUserNames: [String]?

    public init(id: String, tenantId: String, userId: String? = nil, anonUserId: String? = nil, urlId: String, url: String, pageTitle: String? = nil, relatedObjectType: NotificationObjectType, relatedObjectId: String, viewed: Bool, isUnreadMessage: Bool, sent: Bool, createdAt: Date, type: NotificationType, fromCommentId: String? = nil, fromVoteId: String? = nil, fromUserName: String? = nil, fromUserId: String? = nil, fromUserAvatarSrc: String? = nil, optedOut: Bool, count: Int64? = nil, relatedIds: [String]? = nil, fromUserIds: [String]? = nil, fromUserNames: [String]? = nil) {
        self.id = id
        self.tenantId = tenantId
        self.userId = userId
        self.anonUserId = anonUserId
        self.urlId = urlId
        self.url = url
        self.pageTitle = pageTitle
        self.relatedObjectType = relatedObjectType
        self.relatedObjectId = relatedObjectId
        self.viewed = viewed
        self.isUnreadMessage = isUnreadMessage
        self.sent = sent
        self.createdAt = createdAt
        self.type = type
        self.fromCommentId = fromCommentId
        self.fromVoteId = fromVoteId
        self.fromUserName = fromUserName
        self.fromUserId = fromUserId
        self.fromUserAvatarSrc = fromUserAvatarSrc
        self.optedOut = optedOut
        self.count = count
        self.relatedIds = relatedIds
        self.fromUserIds = fromUserIds
        self.fromUserNames = fromUserNames
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id = "_id"
        case tenantId
        case userId
        case anonUserId
        case urlId
        case url
        case pageTitle
        case relatedObjectType
        case relatedObjectId
        case viewed
        case isUnreadMessage
        case sent
        case createdAt
        case type
        case fromCommentId
        case fromVoteId
        case fromUserName
        case fromUserId
        case fromUserAvatarSrc
        case optedOut
        case count
        case relatedIds
        case fromUserIds
        case fromUserNames
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(tenantId, forKey: .tenantId)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(anonUserId, forKey: .anonUserId)
        try container.encode(urlId, forKey: .urlId)
        try container.encode(url, forKey: .url)
        try container.encodeIfPresent(pageTitle, forKey: .pageTitle)
        try container.encode(relatedObjectType, forKey: .relatedObjectType)
        try container.encode(relatedObjectId, forKey: .relatedObjectId)
        try container.encode(viewed, forKey: .viewed)
        try container.encode(isUnreadMessage, forKey: .isUnreadMessage)
        try container.encode(sent, forKey: .sent)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(fromCommentId, forKey: .fromCommentId)
        try container.encodeIfPresent(fromVoteId, forKey: .fromVoteId)
        try container.encodeIfPresent(fromUserName, forKey: .fromUserName)
        try container.encodeIfPresent(fromUserId, forKey: .fromUserId)
        try container.encodeIfPresent(fromUserAvatarSrc, forKey: .fromUserAvatarSrc)
        try container.encode(optedOut, forKey: .optedOut)
        try container.encodeIfPresent(count, forKey: .count)
        try container.encodeIfPresent(relatedIds, forKey: .relatedIds)
        try container.encodeIfPresent(fromUserIds, forKey: .fromUserIds)
        try container.encodeIfPresent(fromUserNames, forKey: .fromUserNames)
    }
}

