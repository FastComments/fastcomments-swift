//
// QuestionConfig.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct QuestionConfig: Sendable, Codable, JSONEncodable, Hashable {

    public var id: String
    public var tenantId: String
    public var name: String
    public var question: String
    public var summaryLabel: String?
    public var helpText: String
    public var createdAt: Date
    public var createdBy: String
    public var usedCount: Double
    public var lastUsed: Date
    public var type: String
    public var numStars: Double
    public var min: Double
    public var max: Double
    public var defaultValue: Double
    public var labelNegative: String
    public var labelPositive: String
    public var customOptions: [QuestionConfigCustomOptionsInner]
    public var subQuestionIds: [String]
    public var alwaysShowSubQuestions: Bool
    public var reportingOrder: Double

    public init(id: String, tenantId: String, name: String, question: String, summaryLabel: String? = nil, helpText: String, createdAt: Date, createdBy: String, usedCount: Double, lastUsed: Date, type: String, numStars: Double, min: Double, max: Double, defaultValue: Double, labelNegative: String, labelPositive: String, customOptions: [QuestionConfigCustomOptionsInner], subQuestionIds: [String], alwaysShowSubQuestions: Bool, reportingOrder: Double) {
        self.id = id
        self.tenantId = tenantId
        self.name = name
        self.question = question
        self.summaryLabel = summaryLabel
        self.helpText = helpText
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.usedCount = usedCount
        self.lastUsed = lastUsed
        self.type = type
        self.numStars = numStars
        self.min = min
        self.max = max
        self.defaultValue = defaultValue
        self.labelNegative = labelNegative
        self.labelPositive = labelPositive
        self.customOptions = customOptions
        self.subQuestionIds = subQuestionIds
        self.alwaysShowSubQuestions = alwaysShowSubQuestions
        self.reportingOrder = reportingOrder
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id = "_id"
        case tenantId
        case name
        case question
        case summaryLabel
        case helpText
        case createdAt
        case createdBy
        case usedCount
        case lastUsed
        case type
        case numStars
        case min
        case max
        case defaultValue
        case labelNegative
        case labelPositive
        case customOptions
        case subQuestionIds
        case alwaysShowSubQuestions
        case reportingOrder
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(tenantId, forKey: .tenantId)
        try container.encode(name, forKey: .name)
        try container.encode(question, forKey: .question)
        try container.encodeIfPresent(summaryLabel, forKey: .summaryLabel)
        try container.encode(helpText, forKey: .helpText)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(createdBy, forKey: .createdBy)
        try container.encode(usedCount, forKey: .usedCount)
        try container.encode(lastUsed, forKey: .lastUsed)
        try container.encode(type, forKey: .type)
        try container.encode(numStars, forKey: .numStars)
        try container.encode(min, forKey: .min)
        try container.encode(max, forKey: .max)
        try container.encode(defaultValue, forKey: .defaultValue)
        try container.encode(labelNegative, forKey: .labelNegative)
        try container.encode(labelPositive, forKey: .labelPositive)
        try container.encode(customOptions, forKey: .customOptions)
        try container.encode(subQuestionIds, forKey: .subQuestionIds)
        try container.encode(alwaysShowSubQuestions, forKey: .alwaysShowSubQuestions)
        try container.encode(reportingOrder, forKey: .reportingOrder)
    }
}

