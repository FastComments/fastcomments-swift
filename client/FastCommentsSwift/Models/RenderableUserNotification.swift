//
// RenderableUserNotification.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct RenderableUserNotification: Sendable, Codable, JSONEncodable, Hashable {

    public var conversationId: String?
    public var contextHTML: String?
    public var fromUserNames: [String]?
    public var fromUserIds: [String]?
    public var relatedIds: [String]?
    public var count: Int64?
    public var optedOut: Bool
    public var fromUserAvatarSrc: String?
    public var fromUserId: String?
    public var fromUserName: String?
    public var fromCommentId: String?
    public var type: NotificationType
    public var createdAt: String
    public var sent: String
    public var viewed: String
    public var relatedObjectId: String
    public var relatedObjectType: NotificationObjectType
    public var pageTitle: String?
    public var url: String
    public var urlId: String
    public var id: String

    public init(conversationId: String? = nil, contextHTML: String? = nil, fromUserNames: [String]? = nil, fromUserIds: [String]? = nil, relatedIds: [String]? = nil, count: Int64? = nil, optedOut: Bool, fromUserAvatarSrc: String? = nil, fromUserId: String? = nil, fromUserName: String? = nil, fromCommentId: String? = nil, type: NotificationType, createdAt: String, sent: String, viewed: String, relatedObjectId: String, relatedObjectType: NotificationObjectType, pageTitle: String? = nil, url: String, urlId: String, id: String) {
        self.conversationId = conversationId
        self.contextHTML = contextHTML
        self.fromUserNames = fromUserNames
        self.fromUserIds = fromUserIds
        self.relatedIds = relatedIds
        self.count = count
        self.optedOut = optedOut
        self.fromUserAvatarSrc = fromUserAvatarSrc
        self.fromUserId = fromUserId
        self.fromUserName = fromUserName
        self.fromCommentId = fromCommentId
        self.type = type
        self.createdAt = createdAt
        self.sent = sent
        self.viewed = viewed
        self.relatedObjectId = relatedObjectId
        self.relatedObjectType = relatedObjectType
        self.pageTitle = pageTitle
        self.url = url
        self.urlId = urlId
        self.id = id
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case conversationId
        case contextHTML
        case fromUserNames
        case fromUserIds
        case relatedIds
        case count
        case optedOut
        case fromUserAvatarSrc
        case fromUserId
        case fromUserName
        case fromCommentId
        case type
        case createdAt
        case sent
        case viewed
        case relatedObjectId
        case relatedObjectType
        case pageTitle
        case url
        case urlId
        case id = "_id"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(conversationId, forKey: .conversationId)
        try container.encodeIfPresent(contextHTML, forKey: .contextHTML)
        try container.encodeIfPresent(fromUserNames, forKey: .fromUserNames)
        try container.encodeIfPresent(fromUserIds, forKey: .fromUserIds)
        try container.encodeIfPresent(relatedIds, forKey: .relatedIds)
        try container.encodeIfPresent(count, forKey: .count)
        try container.encode(optedOut, forKey: .optedOut)
        try container.encodeIfPresent(fromUserAvatarSrc, forKey: .fromUserAvatarSrc)
        try container.encodeIfPresent(fromUserId, forKey: .fromUserId)
        try container.encodeIfPresent(fromUserName, forKey: .fromUserName)
        try container.encodeIfPresent(fromCommentId, forKey: .fromCommentId)
        try container.encode(type, forKey: .type)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(sent, forKey: .sent)
        try container.encode(viewed, forKey: .viewed)
        try container.encode(relatedObjectId, forKey: .relatedObjectId)
        try container.encode(relatedObjectType, forKey: .relatedObjectType)
        try container.encodeIfPresent(pageTitle, forKey: .pageTitle)
        try container.encode(url, forKey: .url)
        try container.encode(urlId, forKey: .urlId)
        try container.encode(id, forKey: .id)
    }
}

